// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NOTE: We keep string-based "enums" (status/role/type fields) for portability.
// Validate allowed values in application code.
// For structured data (blocks, tags, sensations, meta) we store JSON strings
// in TEXT-like columns (String in Prisma).

// ------------------------
// Core User & Social Graph
// ------------------------

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  password       String? // hashed password for email/password auth
  name           String?
  emailVerified  DateTime?
  createdAt      DateTime  @default(now())
  lastSeen       DateTime? // Track last active time for online status
  // Follower/Following counts for real-time updates
  followersCount Int       @default(0)
  followingCount Int       @default(0)

  // Relations
  profile         Profile?
  posts           Post[]
  media           Media[]
  groupsOwned     Group[]             @relation("GroupsOwned")
  groupMembers    GroupMember[]
  friendshipsA    Friendship[]        @relation("A")
  friendshipsB    Friendship[]        @relation("B")
  happiness       HappinessScore[]
  userValues      UserValue[]
  bonds           BondBlueprint[]
  drills          ConflictDrill[]
  passkeys        PasskeyCredential[]
  serendipityLogs SerendipityLog[]

  // New: metrics back-relation
  metrics Metric[]

  // New: journaling & templates
  journalEntries   JournalEntry[]
  journalTemplates JournalTemplate[]

  // Invites back-relation
  invitesSent Invite[]

  // --- Work management back-relations (added) ---
  orgsOwned       Organization[]      @relation("OrgOwner")
  orgMembership   OrgMember[]
  tasksCreated    Task[]              @relation("TaskCreator")
  taskAssignee    TaskAssignee[]
  checklistChecks TaskChecklistItem[] @relation("ChecklistCheckedBy")
  taskComments    TaskComment[]       @relation("TaskCommentAuthor")
  taskVolunteers  TaskVolunteer[]
  reminders       Reminder[]

  // --- Auth.js / NextAuth back-relations ---
  accounts     Account[]
  sessions     Session[]
  postLikes    PostLike[]
  postComments PostComment[]

  // --- Chat & Messaging ---
  conversationsA     Conversation[]              @relation("ConversationA")
  conversationsB     Conversation[]              @relation("ConversationB")
  messagesSent       Message[]                   @relation("MessagesSent")
  chatSessions       ChatSessionLog[]            @relation("ChatSessions")
  chatAnalytics      ChatAnalytics?              @relation("Analytics")
  featureSessions    FeatureSession[]            @relation("FeatureSessions")
  featureParticipant FeatureSessionParticipant[] @relation("FeatureParticipants")
  conversationStates ConversationState[]

  // --- Collaboration Features ---
  collaborationInvitesSent     CollaborationInvite[] @relation("CollaborationInvitesSent")
  collaborationInvitesReceived CollaborationInvite[] @relation("CollaborationInvitesReceived")
  collaborationUpdates         CollaborationUpdate[]

  // --- AI Chatbot ("dbot") ---
  userInsights   UserInsight[]
  aiChatSessions AIChatSession[]

  // --- Shop & E-commerce ---
  brandsOwned    Brand[]         @relation("BrandsOwned")
  productReviews ProductReview[] @relation("ProductReviews")
  brandReviews   BrandReview[]   @relation("BrandReviews")
  orders         Order[]         @relation("Orders")
  payments       Payment[] // Razorpay payments

  // --- User Marketplace ---
  profileCard    ProfileCard?
  productsSold Product[]     @relation("ProductsSold")
  productViews ProductView[] @relation("ProductViews")

  // --- Awe Routes & Places ---
  waypoints        RouteWaypoint[]
  waypointPhotos   WaypointPhoto[]   @relation("WaypointPhotoAuthor")
  photoShares      PhotoShare[]      @relation("PhotoShareRecipient")
  placeReviews     PlaceReview[]
  placePhotos      PlacePhoto[]      @relation("PlacePhotoAuthor")
  placePhotoShares PlacePhotoShare[] @relation("PlacePhotoShareRecipient")

  // --- Breathing App ---
  breathingReactions BreathingReaction[]

  // --- Wrex (Gym Partners & Workout Plans) ---
  gymPartnersSent     GymPartner[]  @relation("GymPartnerSender")
  gymPartnersReceived GymPartner[]  @relation("GymPartnerReceiver")
  workoutPlans        WorkoutPlan[]

  // --- Hopin Plans ---
  plansCreated    Plan[]       @relation("PlanCreator")
  planMemberships PlanMember[]
}

model Plan {
  id          String   @id @default(cuid())
  title       String
  description String?
  creatorId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  creator User         @relation("PlanCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  members PlanMember[]

  @@index([creatorId])
}

model PlanMember {
  id        String   @id @default(cuid())
  planId    String
  userId    String
  status    String   @default("PENDING") // PENDING, ACCEPTED, REJECTED
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  plan Plan @relation(fields: [planId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([planId, userId])
  @@index([planId])
  @@index([userId])
}

model BreathingReaction {
  id          String   @id @default(cuid())
  userId      String
  techniqueId Int // Matches the ID in your static list
  // Allowed: LIKE | DISLIKE | OPINION
  type        String
  content     String? // For opinions
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, techniqueId, type]) // One like/dislike per user per technique (opinions can be multiple if you remove type from unique, but usually one opinion is enough or handle differently)
  @@index([techniqueId])
}

model GymPartner {
  id        String   @id @default(cuid())
  userId    String // The sender
  partnerId String // The receiver
  status    String   @default("PENDING") // PENDING | ACCEPTED | REJECTED
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User @relation("GymPartnerSender", fields: [userId], references: [id], onDelete: Cascade)
  partner User @relation("GymPartnerReceiver", fields: [partnerId], references: [id], onDelete: Cascade)

  @@unique([userId, partnerId])
  @@index([userId])
  @@index([partnerId])
}

model WorkoutPlan {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?
  frequency   String   @default("3x")
  duration    Int      @default(12) // Weeks
  exercises   String // JSON string of Exercise[]
  schedule    String? // JSON string of schedule mapping
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Profile {
  userId        String  @id
  displayName   String?
  avatarUrl     String?
  bio           String?
  location      String?
  tags          String?
  coverVideoUrl String? // <â€” NEW
  isPrivate     Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Group {
  id          String   @id @default(cuid())
  name        String
  description String?
  ownerId     String
  createdAt   DateTime @default(now())

  owner   User          @relation("GroupsOwned", fields: [ownerId], references: [id], onDelete: Cascade)
  members GroupMember[]
  posts   Post[]
}

model GroupMember {
  id        String   @id @default(cuid())
  userId    String
  groupId   String
  // Allowed: OWNER | ADMIN | MEMBER
  role      String   @default("MEMBER")
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
}

model Friendship {
  id        String   @id @default(cuid())
  userId    String
  friendId  String
  // Allowed: PENDING | ACCEPTED | BLOCKED | GHOSTED
  status    String   @default("PENDING")
  // Track if request was ghosted by the recipient
  isGhosted Boolean  @default(false)
  // ID of user who ghosted (the recipient if ghosted)
  ghostedBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User @relation("A", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("B", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
}

model Post {
  id              String   @id @default(cuid())
  userId          String
  groupId         String?
  // Allowed: JOURNAL | JOY | AWE | BONDS | SERENDIPITY | CHECKIN | PROGRESS | OTHER
  feature         String   @default("OTHER")
  // NEW: Post type - STANDARD | CHAPTER | XRAY | BTS | LILL | FILL | AUD | CHAN | PULLUPDOWN
  postType        String   @default("STANDARD")
  content         String
  // Allowed: PUBLIC | FRIENDS | PRIVATE
  visibility      String   @default("PUBLIC")
  joyScore        Int      @default(0)
  connectionScore Int      @default(0)
  creativityScore Int      @default(0)
  createdAt       DateTime @default(now())

  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  group    Group?        @relation(fields: [groupId], references: [id], onDelete: SetNull)
  media    Media[]
  likes    PostLike[]
  comments PostComment[]
  shares   PostShare[]

  // Relations to new post types
  chapterData    Chapter?
  xrayData       Xray?
  btsData        BTS?
  lillData       Lill?
  fillData       Fill?
  audData        Aud?
  chanData       Chan?
  pullUpDownData PullUpDown?

  @@index([postType])
  @@index([createdAt])
}

model PostLike {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([postId])
  @@index([userId])
}

model PostComment {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  content   String
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
}

model PostShare {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  toUserId  String?
  toGroupId String?
  message   String?
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
  @@index([toUserId])
  @@index([toGroupId])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  message   String
  postId    String?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, read])
  @@index([createdAt])
}

model Media {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  // Mirrors post feature: JOURNAL | JOY | ...
  feature   String   @default("OTHER")
  // Allowed: IMAGE | VIDEO | AUDIO
  type      String
  url       String
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ========================
// Advanced Post Types
// ========================

// Chapters - Multi-media collections with linking
model Chapter {
  id              String   @id @default(cuid())
  postId          String   @unique
  title           String?
  description     String?
  linkedChapterId String? // Link to previous chapter
  linkedPostId    String? // Link to any previous post
  mediaUrls       String // JSON array of media URLs
  mediaTypes      String // JSON array of media types (image/video/audio/text)
  orderIndex      Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  post          Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  linkedChapter Chapter?  @relation("ChapterLinks", fields: [linkedChapterId], references: [id], onDelete: SetNull)
  nextChapters  Chapter[] @relation("ChapterLinks")

  @@index([postId])
  @@index([linkedChapterId])
  @@index([createdAt])
}

// Xrays - 2-layer interactive scratch posts
model Xray {
  id              String   @id @default(cuid())
  postId          String   @unique
  topLayerUrl     String // Image/video URL for top layer
  topLayerType    String // IMAGE | VIDEO
  bottomLayerUrl  String // Image/video URL revealed on scratch
  bottomLayerType String // IMAGE | VIDEO
  scratchPattern  String   @default("RANDOM") // RANDOM | GRID | CUSTOM
  revealPercent   Int      @default(0) // Percentage revealed (for analytics)
  createdAt       DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
}

// BTS - Behind the scenes (credits, tools, mindmaps)
model BTS {
  id          String   @id @default(cuid())
  postId      String   @unique
  credits     String? // JSON array of {name, role, link}
  tools       String? // JSON array of {name, category, link}
  mindmapData String? // JSON mindmap structure
  links       String? // JSON array of {title, url, description}
  resources   String? // JSON array of additional resources
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
}

// Lills - Short-form videos (like reels)
model Lill {
  id           String   @id @default(cuid())
  postId       String   @unique
  videoUrl     String
  thumbnailUrl String?
  duration     Int // Duration in seconds (max 60)
  aspectRatio  String   @default("9:16") // Vertical video
  musicUrl     String? // Optional background music
  musicTitle   String?
  filters      String? // JSON array of applied filters
  createdAt    DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([createdAt])
}

// Fills - Long-form videos (YouTube-style)
model Fill {
  id           String   @id @default(cuid())
  postId       String   @unique
  videoUrl     String
  thumbnailUrl String?
  duration     Int // Duration in seconds
  aspectRatio  String   @default("16:9") // Horizontal video
  chapters     String? // JSON array of {time, title} for video chapters
  subtitlesUrl String? // Optional subtitles file
  quality      String   @default("HD") // SD | HD | FHD | 4K
  createdAt    DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([createdAt])
}

// Auds - Audio files
model Aud {
  id            String   @id @default(cuid())
  postId        String   @unique
  audioUrl      String
  duration      Int // Duration in seconds
  waveformData  String? // JSON array of amplitude values for visualization
  coverImageUrl String? // Optional cover art
  artist        String?
  title         String?
  genre         String?
  createdAt     DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([createdAt])
}

// Chans - Channels with episodes/scheduled content
model Chan {
  id              String   @id @default(cuid())
  postId          String   @unique
  channelName     String
  description     String?
  coverImageUrl   String?
  schedule        String? // JSON array of {day, time, title}
  isLive          Boolean  @default(false)
  liveUrl         String? // URL for live stream if active
  episodes        String // JSON array of {title, url, thumbnail, duration, publishedAt}
  subscriberCount Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([isLive])
  @@index([createdAt])
}

// PullUpDown - Voting/polling posts
model PullUpDown {
  id            String    @id @default(cuid())
  postId        String    @unique
  question      String
  optionA       String // First option
  optionB       String // Second option
  optionACount  Int       @default(0)
  optionBCount  Int       @default(0)
  allowMultiple Boolean   @default(false)
  expiresAt     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  post  Post             @relation(fields: [postId], references: [id], onDelete: Cascade)
  votes PullUpDownVote[]

  @@index([postId])
  @@index([expiresAt])
}

// Track individual votes for PullUpDown
model PullUpDownVote {
  id           String   @id @default(cuid())
  pullUpDownId String
  userId       String
  vote         String // A | B
  createdAt    DateTime @default(now())

  pullUpDown PullUpDown @relation(fields: [pullUpDownId], references: [id], onDelete: Cascade)

  @@unique([pullUpDownId, userId])
  @@index([pullUpDownId])
  @@index([userId])
}

model HappinessScore {
  id        String   @id @default(cuid())
  userId    String
  // Allowed: JOY | CONNECTION | CREATIVITY
  category  String
  value     Int
  // Source feature: JOURNAL | JOY | AWE | BONDS | SERENDIPITY | CHECKIN | PROGRESS | OTHER
  source    String   @default("OTHER")
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Value {
  id    String @id @default(cuid())
  slug  String @unique
  label String

  userValues UserValue[]
}

model UserValue {
  id      String @id @default(cuid())
  userId  String
  valueId String
  rank    Int

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  value Value @relation(fields: [valueId], references: [id], onDelete: Cascade)

  @@unique([userId, valueId])
}

model BondBlueprint {
  id         String   @id @default(cuid())
  userId     String
  personName String
  goal       String?
  notes      String?
  createdAt  DateTime @default(now())

  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  drills ConflictDrill[]
}

model ConflictDrill {
  id          String    @id @default(cuid())
  userId      String
  blueprintId String?
  notes       String?
  resolvedAt  DateTime?
  createdAt   DateTime  @default(now())

  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  blueprint BondBlueprint? @relation(fields: [blueprintId], references: [id], onDelete: SetNull)
}

model PasskeyCredential {
  id                  String  @id @default(cuid())
  userId              String
  credentialID        String  @unique // base64url
  credentialPublicKey String // base64url
  counter             Int     @default(0)
  transports          String? // comma-separated list
  aaguid              String? // optional

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model SerendipityLog {
  id        String   @id @default(cuid())
  userId    String
  weekNum   Int
  year      Int
  packId    String?
  completed Boolean  @default(false)
  notes     String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, weekNum, year])
}

// New: Generic metrics table for stats from any feature (e.g., stress_avg_intensity, calm_index).
// Stores a numeric value plus optional category. User is optional to allow anonymous.
model Metric {
  id        String   @id @default(cuid())
  userId    String?
  type      String
  category  String?
  value     Float
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([type, createdAt])
  @@index([userId, type, createdAt])
}

// ------------------------
// Journaling (Canvas + Templates)
// ------------------------

model JournalEntry {
  id               String    @id @default(cuid())
  userId           String
  content          String
  blocks           String? // JSON string: [{ id, type: "TEXT" | "IMAGE" | "VIDEO" | "AUDIO", ... }]
  // Optional extras used by your UI (all optional to keep flexible)
  mood             Int?
  moodColor        String?
  tags             String? // JSON string: ["gratitude","walk"]
  sensations       String? // JSON string: [{ zone: "Chest", note: "tight" }]
  meta             String? // JSON string: template blocks used, persona, etc.
  unlockAt         DateTime?
  shadowPassphrase String? // store hashed in API if sensitive
  visibility       String    @default("PRIVATE") // if you ever expose journals themselves

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([visibility, createdAt])
}

// Reusable canvas templates users can publish or keep private.
// Blocks are stored as JSON string in TEXT; owner is required.
model JournalTemplate {
  id          String  @id @default(cuid())
  userId      String
  name        String
  description String?
  visibility  String  @default("PRIVATE") // PUBLIC | PRIVATE
  blocks      String // JSON string
  author      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([visibility, createdAt])
}

// ------------------------
// Invites (added)
// ------------------------

model Invite {
  id         String    @id @default(cuid())
  token      String    @unique
  email      String?
  username   String?
  inviterId  String
  status     String    @default("PENDING") // PENDING | ACCEPTED | REVOKED | EXPIRED
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  acceptedAt DateTime?
  revokedAt  DateTime?

  inviter User @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@index([inviterId])
  @@index([status, expiresAt])
}

// ------------------------
// Work Management (Organizations / Projects / Tasks)
// ------------------------

model Organization {
  id          String   @id @default(cuid())
  name        String
  description String?
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner    User        @relation("OrgOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members  OrgMember[]
  projects Project[]
  tags     Tag[]
}

model OrgMember {
  id             String   @id @default(cuid())
  organizationId String
  userId         String
  role           String   @default("MEMBER") // ADMIN | MANAGER | MEMBER
  createdAt      DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([organizationId])
  @@index([userId])
}

model Project {
  id             String    @id @default(cuid())
  organizationId String
  name           String
  description    String?
  status         String    @default("ACTIVE") // ACTIVE | ARCHIVED
  startDate      DateTime?
  dueDate        DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  tasks        Task[]

  @@index([organizationId])
  @@index([status])
  @@index([dueDate])
}

model Task {
  id              String    @id @default(cuid())
  projectId       String
  title           String
  description     String?
  status          String    @default("TODO") // TODO | IN_PROGRESS | REVIEW | DONE
  priority        String    @default("MEDIUM") // LOW | MEDIUM | HIGH | URGENT
  startDate       DateTime?
  dueDate         DateTime?
  createdById     String
  timeEstimateMin Int?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  createdBy User    @relation("TaskCreator", fields: [createdById], references: [id], onDelete: Cascade)

  assignees  TaskAssignee[]
  checklist  TaskChecklistItem[]
  comments   TaskComment[]
  tags       TaskTag[]
  reminders  Reminder[]
  volunteers TaskVolunteer[]

  @@index([projectId])
  @@index([status])
  @@index([dueDate])
}

model TaskAssignee {
  id         String   @id @default(cuid())
  taskId     String
  userId     String
  assignedAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskId, userId])
  @@index([userId])
}

model TaskChecklistItem {
  id          String    @id @default(cuid())
  taskId      String
  label       String
  completed   Boolean   @default(false)
  checkedById String?
  checkedAt   DateTime?

  task      Task  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  checkedBy User? @relation("ChecklistCheckedBy", fields: [checkedById], references: [id], onDelete: SetNull)

  @@index([taskId])
  @@index([checkedById])
}

model TaskComment {
  id        String   @id @default(cuid())
  taskId    String
  authorId  String
  body      String
  createdAt DateTime @default(now())

  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  author User @relation("TaskCommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@index([authorId])
}

model Tag {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  colorHex       String?
  createdAt      DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  taskTags     TaskTag[]

  @@unique([organizationId, name])
  @@index([organizationId])
}

model TaskTag {
  id     String @id @default(cuid())
  taskId String
  tagId  String

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([taskId, tagId])
  @@index([tagId])
}

model TaskVolunteer {
  id        String   @id @default(cuid())
  taskId    String
  userId    String
  status    String   @default("REQUESTED") // REQUESTED | APPROVED | DECLINED
  createdAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([taskId, userId])
  @@index([userId])
}

model Reminder {
  id        String   @id @default(cuid())
  taskId    String
  userId    String
  triggerAt DateTime
  type      String   @default("DUE") // DUE | START | CUSTOM
  sent      Boolean  @default(false)
  createdAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([triggerAt, sent])
  @@index([userId])
}

// ------------------------
// Chat & Messaging System
// ------------------------

model Conversation {
  id            String    @id @default(cuid())
  participantA  String // userId of participant A
  participantB  String // userId of participant B
  lastMessage   String?
  lastMessageAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  userA                User                  @relation("ConversationA", fields: [participantA], references: [id], onDelete: Cascade)
  userB                User                  @relation("ConversationB", fields: [participantB], references: [id], onDelete: Cascade)
  messages             Message[]
  sessionLogs          ChatSessionLog[]
  collaborationInvites CollaborationInvite[]

  states ConversationState[]

  @@unique([participantA, participantB])
  @@index([participantA])
  @@index([participantB])
  @@index([lastMessageAt])
}

model ConversationState {
  id             String    @id @default(cuid())
  conversationId String
  userId         String
  isDeleted      Boolean   @default(false)
  isMuted        Boolean   @default(false)
  lastDeletedAt  DateTime? // To hide messages before this date if "deleted"
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String    @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  readAt         DateTime?
  createdAt      DateTime  @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("MessagesSent", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
}

model ChatSessionLog {
  id              String    @id @default(cuid())
  conversationId  String
  userId          String
  startTime       DateTime  @default(now())
  endTime         DateTime?
  durationMinutes Int? // Calculated duration

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation("ChatSessions", fields: [userId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([userId])
  @@index([startTime])
}

model ChatAnalytics {
  id                    String   @id @default(cuid())
  userId                String
  totalMessagesCount    Int      @default(0)
  totalChatTimeMinutes  Int      @default(0)
  mostFrequentContactId String?
  lastAnalyzedAt        DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user User @relation("Analytics", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
  @@index([userId])
}

// Feature Collaboration: Track collaborative sessions
model FeatureSession {
  id             String   @id @default(cuid())
  type           String // "JOURNALING" | "HOPPING" | "BONDING" | "BREATHING"
  creatorId      String
  conversationId String? // Link to chat for planning
  title          String?
  description    String?
  status         String   @default("ACTIVE") // ACTIVE | ARCHIVED
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Collaboration features
  canvasData      String? // JSON: blocks, drawing state
  autoSaveEnabled Boolean   @default(true)
  lastSavedAt     DateTime?
  lastModifiedBy  String?
  syncVersion     Int       @default(0)

  creator      User                        @relation("FeatureSessions", fields: [creatorId], references: [id], onDelete: Cascade)
  participants FeatureSessionParticipant[]
  invites      CollaborationInvite[]
  updates      CollaborationUpdate[]

  @@index([creatorId])
  @@index([type])
  @@index([status])
  @@index([lastModifiedBy])
  @@index([updatedAt])
}

model FeatureSessionParticipant {
  id        String   @id @default(cuid())
  sessionId String
  userId    String
  joinedAt  DateTime @default(now())
  status    String   @default("ACTIVE") // ACTIVE | LEFT | INVITED

  session FeatureSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user    User           @relation("FeatureParticipants", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
}

// Collaboration Invites - for messaging system
model CollaborationInvite {
  id             String    @id @default(cuid())
  sessionId      String
  fromUserId     String
  toUserId       String
  featureType    String // CANVAS | HOPIN | BREATHING | etc.
  status         String    @default("PENDING") // PENDING | ACCEPTED | REJECTED | CANCELLED
  messageId      String?
  conversationId String
  createdAt      DateTime  @default(now())
  respondedAt    DateTime?

  session      FeatureSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  fromUser     User           @relation("CollaborationInvitesSent", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser       User           @relation("CollaborationInvitesReceived", fields: [toUserId], references: [id], onDelete: Cascade)
  conversation Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([sessionId, fromUserId, toUserId])
  @@index([sessionId])
  @@index([fromUserId])
  @@index([toUserId])
  @@index([conversationId])
  @@index([status])
  @@index([createdAt])
}

// Collaboration Updates - for tracking changes in real-time
model CollaborationUpdate {
  id        String   @id @default(cuid())
  sessionId String
  userId    String
  operation String // ADD_BLOCK | UPDATE_BLOCK | REMOVE_BLOCK | DRAW | SAVE
  blockId   String?
  data      String // JSON: the actual change data
  timestamp DateTime @default(now())
  synced    Boolean  @default(false)

  session FeatureSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([userId])
  @@index([timestamp])
  @@index([synced])
  @@index([sessionId, timestamp])
}

// ------------------------
// Auth.js / NextAuth tables
// ------------------------

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ========================
// Shop & E-commerce System
// ========================

model Brand {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  logoUrl     String?
  bannerUrl   String?
  ownerId     String
  isVerified  Boolean  @default(false)
  status      String   @default("ACTIVE") // ACTIVE, SUSPENDED, INACTIVE
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  websiteUrl   String?
  competitors  Brand[] @relation("BrandCompetitors")
  competitorOf Brand[] @relation("BrandCompetitors")

  owner        User            @relation("BrandsOwned", fields: [ownerId], references: [id], onDelete: Cascade)
  products     Product[]
  reviews      BrandReview[]
  analyticsLog BrandAnalytics?

  @@index([ownerId])
  @@index([status])
}

model Product {
  id              String  @id @default(cuid())
  brandId         String?
  sellerId        String?
  name            String
  slug            String
  description     String?
  price           Float
  externalUrl     String  @default("") // URL to buy the product
  discountPrice   Float?
  discountPercent Int? // 0-100
  stock           Int     @default(0)
  category        String? // CLOTHING, ELECTRONICS, ACCESSORIES, etc.

  // New fields for Digital Marketplace
  type             String   @default("PHYSICAL") // PHYSICAL, COURSE, EBOOK, DIGITAL_ASSET, TEMPLATE, HOPIN_PLAN
  digitalFileUrl   String? // For Ebooks, Assets
  linkedResourceId String? // ID of the Canvas Template or Hopin Plan
  images           String? // JSON array of image URLs
  tags             String? // JSON array of tags
  status           String   @default("ACTIVE") // ACTIVE, INACTIVE, DISCONTINUED
  isTrending       Boolean  @default(false)
  isFeatured       Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  brand        Brand?            @relation(fields: [brandId], references: [id], onDelete: Cascade)
  seller       User?             @relation("ProductsSold", fields: [sellerId], references: [id], onDelete: Cascade)
  reviews      ProductReview[]
  orderItems   OrderItem[]
  analyticsLog ProductAnalytics?
  views        ProductView[]

  @@unique([brandId, slug])
  @@index([brandId])
  @@index([sellerId])
  @@index([category])
  @@index([status])
  @@index([isTrending])
  @@index([isFeatured])
  @@index([type])
}

model ProductView {
  id        String   @id @default(cuid())
  productId String
  userId    String?
  viewedAt  DateTime @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user    User?   @relation("ProductViews", fields: [userId], references: [id], onDelete: SetNull)

  @@index([productId])
  @@index([userId])
  @@index([viewedAt])
}

model ProductReview {
  id        String   @id @default(cuid())
  productId String
  userId    String
  rating    Int // 1-5
  comment   String?
  images    String? // JSON array
  createdAt DateTime @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user    User    @relation("ProductReviews", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([productId, userId])
  @@index([productId])
  @@index([userId])
}

model BrandReview {
  id        String   @id @default(cuid())
  brandId   String
  userId    String
  rating    Int // 1-5
  comment   String?
  createdAt DateTime @default(now())

  brand Brand @relation(fields: [brandId], references: [id], onDelete: Cascade)
  user  User  @relation("BrandReviews", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([brandId, userId])
  @@index([brandId])
  @@index([userId])
}

model Order {
  id              String   @id @default(cuid())
  userId          String
  status          String   @default("PENDING") // PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
  totalAmount     Float
  shippingAddress String?
  trackingId      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user    User          @relation("Orders", fields: [userId], references: [id], onDelete: Cascade)
  items   OrderItem[]
  returns OrderReturn[]

  @@index([userId])
  @@index([status])
}

model OrderItem {
  id        String   @id @default(cuid())
  orderId   String
  productId String
  quantity  Int
  price     Float // price at time of order
  createdAt DateTime @default(now())

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([orderId])
  @@index([productId])
}

model OrderReturn {
  id           String   @id @default(cuid())
  orderId      String
  reason       String
  status       String   @default("PENDING") // PENDING, APPROVED, REJECTED, REFUNDED
  refundAmount Float?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([status])
}

model ProductAnalytics {
  id           String   @id @default(cuid())
  productId    String   @unique
  views        Int      @default(0) // Product Details View
  impressions  Int      @default(0) // Store/List View
  purchases    Int      @default(0) // Redirects (renamed concept in UI)
  revenue      Float    @default(0)
  avgRating    Float    @default(0)
  totalReviews Int      @default(0)
  lastUpdated  DateTime @updatedAt

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
}

model BrandAnalytics {
  id               String   @id @default(cuid())
  brandId          String   @unique
  totalViews       Int      @default(0)
  totalImpressions Int      @default(0) // New field
  totalOrders      Int      @default(0) // Redirects
  totalRevenue     Float    @default(0)
  activeUsers      Int      @default(0)
  avgRating        Float    @default(0)
  lastUpdated      DateTime @updatedAt

  brand Brand @relation(fields: [brandId], references: [id], onDelete: Cascade)

  @@index([brandId])
}

model Deal {
  id            String   @id @default(cuid())
  brandId       String? // If null, it's a platform-wide deal
  productIds    String // JSON array of product IDs
  title         String
  description   String?
  discountType  String // PERCENTAGE, FIXED_AMOUNT
  discountValue Float
  startDate     DateTime
  endDate       DateTime
  status        String   @default("ACTIVE") // ACTIVE, ENDED, SCHEDULED
  createdAt     DateTime @default(now())

  @@index([brandId])
  @@index([status])
}

// ========================
// Awe Routes - Places & Photos
// ========================

model RouteWaypoint {
  id          String   @id @default(cuid())
  userId      String
  routeId     String // OSM place ID or custom identifier
  lat         Float
  lng         Float
  name        String
  description String?
  emoji       String   @default("ðŸ“") // Visual marker
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  photos WaypointPhoto[]

  @@index([userId])
  @@index([routeId])
  @@index([createdAt])
}

model WaypointPhoto {
  id         String   @id @default(cuid())
  waypointId String
  userId     String
  url        String // URL to uploaded image
  caption    String?
  visibility String   @default("PRIVATE") // PUBLIC, FRIENDS, PRIVATE
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  waypoint RouteWaypoint @relation(fields: [waypointId], references: [id], onDelete: Cascade)
  user     User          @relation("WaypointPhotoAuthor", fields: [userId], references: [id], onDelete: Cascade)
  shares   PhotoShare[]

  @@index([waypointId])
  @@index([userId])
  @@index([visibility])
}

model PhotoShare {
  id        String   @id @default(cuid())
  photoId   String
  userId    String // User who the photo is shared with (for FRIENDS sharing)
  createdAt DateTime @default(now())

  // Relations
  photo WaypointPhoto @relation(fields: [photoId], references: [id], onDelete: Cascade)
  user  User          @relation("PhotoShareRecipient", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([photoId, userId])
  @@index([photoId])
  @@index([userId])
}

model PlaceReview {
  id        String    @id @default(cuid())
  userId    String
  osmId     String // OpenStreetMap place ID
  placeName String // Cafe, Restaurant, ATM, etc.
  category  String // POI category
  lat       Float
  lng       Float
  rating    Int // 1-5 stars
  text      String? // Review text
  visited   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  photos PlacePhoto[]

  @@index([userId])
  @@index([osmId])
  @@index([category])
  @@index([createdAt])
}

model PlacePhoto {
  id         String   @id @default(cuid())
  reviewId   String
  userId     String
  url        String // URL to uploaded image
  caption    String?
  visibility String   @default("PUBLIC") // PUBLIC, FRIENDS, PRIVATE
  createdAt  DateTime @default(now())

  // Relations
  review PlaceReview       @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User              @relation("PlacePhotoAuthor", fields: [userId], references: [id], onDelete: Cascade)
  shares PlacePhotoShare[]

  @@index([reviewId])
  @@index([userId])
  @@index([visibility])
}

model PlacePhotoShare {
  id        String   @id @default(cuid())
  photoId   String
  userId    String // User who the photo is shared with
  createdAt DateTime @default(now())

  // Relations
  photo PlacePhoto @relation(fields: [photoId], references: [id], onDelete: Cascade)
  user  User       @relation("PlacePhotoShareRecipient", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([photoId, userId])
  @@index([photoId])
  @@index([userId])
}

// ========================
// Razorpay Payment System
// ========================

model Payment {
  id            String  @id @default(cuid())
  userId        String
  orderId       String // Razorpay order ID
  paymentId     String? // Razorpay payment ID (set after successful payment)
  amount        Float // Amount in rupees
  currency      String  @default("INR")
  // Status: CREATED | AUTHORIZED | CAPTURED | FAILED | REFUNDED
  status        String  @default("CREATED")
  // Payment method: card, netbanking, wallet, upi, etc.
  paymentMethod String?
  // Description of the payment
  description   String?
  // Razorpay receipt ID
  receiptId     String?
  // Failure reason if payment failed
  failureReason String?
  // Refund details (JSON)
  refundData    String?
  // Signature verification
  signatureId   String?
  signatureData String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  webhookLogs WebhookLog[]

  @@unique([orderId])
  @@index([userId])
  @@index([status])
  @@index([paymentId])
  @@index([createdAt])
}

model WebhookLog {
  id              String    @id @default(cuid())
  paymentId       String? // Reference to Payment record
  razorpayEventId String // Razorpay webhook event ID for idempotency
  eventType       String // payment.authorized | payment.captured | payment.failed | refund.created
  // Request payload (stored as JSON string)
  payload         String
  // Signature verification result
  signatureValid  Boolean   @default(false)
  // Processing status: PENDING | PROCESSED | FAILED
  status          String    @default("PENDING")
  // Error message if processing failed
  errorMessage    String?
  // Number of retry attempts
  retryCount      Int       @default(0)
  // Next retry timestamp
  nextRetryAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payment Payment? @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  @@unique([razorpayEventId]) // Ensures idempotency
  @@index([paymentId])
  @@index([eventType])
  @@index([status])
  @@index([createdAt])
}

// ------------------------
// AI Chatbot / Podcaster ("dbot")
// ------------------------

model UserInsight {
  id         String   @id @default(cuid())
  userId     String
  // e.g. "User feels anxious about work", "User likes nature metaphors"
  content    String
  // Confidence score (0.0 - 1.0)
  confidence Float    @default(1.0)
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model AIChatSession {
  id        String   @id @default(cuid())
  userId    String
  title     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages AIChatMessage[]

  @@index([userId])
  @@index([updatedAt])
}

model AIChatMessage {
  id        String   @id @default(cuid())
  sessionId String
  role      String // "user" | "assistant" | "system"
  content   String
  createdAt DateTime @default(now())

  session AIChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
}

// ------------------------
// Profile Cards
// ------------------------

model ProfileCard {
  id        String   @id @default(cuid())
  userId    String   @unique
  uniqueCode String  @unique // 7-digit alphanumeric code
  content   String   // JSON: stores sections, questions, and answers
  theme     String?  // e.g. "dark", "glass", "sunset"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([uniqueCode])
}
